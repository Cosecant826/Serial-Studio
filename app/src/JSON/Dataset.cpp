/*
 * Serial Studio
 * https://serial-studio.com/
 *
 * Copyright (C) 2020â€“2025 Alex Spataru
 *
 * This file is dual-licensed:
 *
 * - Under the GNU GPLv3 (or later) for builds that exclude Pro modules.
 * - Under the Serial Studio Commercial License for builds that include
 *   any Pro functionality.
 *
 * You must comply with the terms of one of these licenses, depending
 * on your use case.
 *
 * For GPL terms, see <https://www.gnu.org/licenses/gpl-3.0.html>
 * For commercial terms, see LICENSE_COMMERCIAL.md in the project root.
 *
 * SPDX-License-Identifier: GPL-3.0-only OR LicenseRef-SerialStudio-Commercial
 */

#include "JSON/Dataset.h"

/**
 * @brief Reads a value from a QJsonObject based on a key, returning a default
 *        value if the key does not exist.
 *
 * This function checks if the given key exists in the provided QJsonObject.
 * If the key is found, it returns the associated value. Otherwise, it returns
 * the specified default value.
 *
 * @param object The QJsonObject to read the data from.
 * @param key The key to look for in the QJsonObject.
 * @param defaultValue The value to return if the key is not found in the
 * QJsonObject.
 * @return The value associated with the key, or the defaultValue if the key is
 * not present.
 */
static QVariant SAFE_READ(const QJsonObject &object, const QString &key,
                          const QVariant &defaultValue)
{
  if (object.contains(key))
    return object.value(key);

  return defaultValue;
}

/**
 * @brief Constructor function, initializes default values
 */
JSON::Dataset::Dataset(const int groupId, const int datasetId)
  : m_uniqueId(0)
  , m_fft(false)
  , m_led(false)
  , m_log(false)
  , m_graph(false)
  , m_displayInOverview(false)
  , m_title("")
  , m_units("")
  , m_widget("")
  , m_value("")
  , m_fftWindowFn("")
  , m_index(0)
  , m_max(0)
  , m_min(0)
  , m_alarm(0)
  , m_ledHigh(1)
  , m_fftSamples(256)
  , m_fftSamplingRate(100)
  , m_groupId(groupId)
  , m_xAxisId(-1)
  , m_datasetId(datasetId)
{
}

/**
 * @brief Returns a globally unique identifier for this dataset within a frame.
 *
 * Unlike index(), which refers to the dataset's position in the input data
 * array, this identifier is assigned after the frame is fully constructed and
 * is guaranteed to be unique across all groups and datasets in the frame. It is
 * used internally by the dashboard system for efficient dataset mapping and
 * updates.
 *
 * @return Globally unique dataset ID within the frame.
 */
quint32 JSON::Dataset::uniqueId() const
{
  return m_uniqueId;
}

/**
 * @return @c true if the UI should generate a FFT plot of this dataset
 */
bool JSON::Dataset::fft() const
{
  return m_fft;
}

/**
 * @return @c true if the UI should generate a LED of this dataset
 */
bool JSON::Dataset::led() const
{
  return m_led;
}

/**
 * @return @c true if the UI should generate a logarithmic plot of this dataset
 */
bool JSON::Dataset::log() const
{
  return m_log;
}

/**
 * @return the field index represented by the current dataset
 */
int JSON::Dataset::index() const
{
  return m_index;
}

/**
 * @return @c true if the UI should graph this dataset
 */
bool JSON::Dataset::graph() const
{
  return m_graph;
}

/**
 * Returns the minimum value of the dataset
 */
double JSON::Dataset::min() const
{
  return qMin(m_min, m_max);
}

/**
 * Returns the maximum value of the dataset
 */
double JSON::Dataset::max() const
{
  return qMax(m_min, m_max);
}

/**
 * Returns the alarm level of the dataset
 */
double JSON::Dataset::alarm() const
{
  return m_alarm;
}

/**
 * Returns the LED active threshold value.
 */
double JSON::Dataset::ledHigh() const
{
  return m_ledHigh;
}

/**
 * Returns whether the dataset widget should appear in the dashboard's
 * overview workspace. When false, it's shown only in its group-specific
 * workspace, keeping the overview focused on key widgets and datasets.
 */
bool JSON::Dataset::displayInOverview() const
{
  return m_displayInOverview;
}

/**
 * @return The title/description of this dataset
 */
const QString &JSON::Dataset::title() const
{
  return m_title;
}

/**
 * @return The value/reading of this dataset
 */
const QString &JSON::Dataset::value() const
{
  return m_value;
}

/**
 * @return The units of this dataset
 */
const QString &JSON::Dataset::units() const
{
  return m_units;
}

/**
 * @return The widget value of this dataset
 */
const QString &JSON::Dataset::widget() const
{
  return m_widget;
}

/**
 * Returns the name of the FFT window function used in the dataset.
 *
 * Common values include "Hann", "Hamming", "Blackman", etc.
 * This setting determines how the signal is windowed before performing
 * the FFT to reduce spectral leakage.
 *
 * @return Reference to the FFT window name.
 */
const QString &JSON::Dataset::fftWindowFn() const
{
  return m_fftWindowFn;
}

/**
 * @return The frame index for the data source for the x-axis, -1 when the
 *         x axis data should be automatically generated by Serial Studio.
 */
int JSON::Dataset::xAxisId() const
{
  return m_xAxisId;
}

/**
 * Returns the maximum freq. for the FFT transform
 */
int JSON::Dataset::fftSamples() const
{
  return qMax(1, m_fftSamples);
}

/**
 * Returns the sampling rate for the FFT transform
 */
int JSON::Dataset::fftSamplingRate() const
{
  return m_fftSamplingRate;
}

/**
 * @return The index of the group to which the dataset belongs to, used by
 *         the project model to easily identify which group/dataset to update
 *         when the user modifies a parameter in the project model.
 */
int JSON::Dataset::groupId() const
{
  return m_groupId;
}

/**
 * @return The index of the dataset relative to the available datasets of the
 *         parent group.
 */
int JSON::Dataset::datasetId() const
{
  return m_datasetId;
}

/**
 * Returns the JSON data that represents this widget
 */
const QJsonObject &JSON::Dataset::jsonData() const
{
  return m_jsonData;
}

/**
 * @brief Encodes the dataset information into a QJsonObject.
 *
 * This function serializes the dataset's properties into a JSON object.
 * Note that the "m_value" field is deliberately excluded from the encoding
 * process.
 *
 * @return A QJsonObject containing the dataset's properties.
 */
QJsonObject JSON::Dataset::serialize() const
{
  QJsonObject o;
  o.insert(QStringLiteral("fft"), m_fft);
  o.insert(QStringLiteral("led"), m_led);
  o.insert(QStringLiteral("log"), m_log);
  o.insert(QStringLiteral("min"), qMin(m_min, m_max));
  o.insert(QStringLiteral("max"), qMax(m_min, m_max));
  o.insert(QStringLiteral("index"), m_index);
  o.insert(QStringLiteral("alarm"), m_alarm);
  o.insert(QStringLiteral("graph"), m_graph);
  o.insert(QStringLiteral("xAxis"), m_xAxisId);
  o.insert(QStringLiteral("ledHigh"), m_ledHigh);
  o.insert(QStringLiteral("fftSamples"), m_fftSamples);
  o.insert(QStringLiteral("title"), m_title.simplified());
  o.insert(QStringLiteral("value"), m_value.simplified());
  o.insert(QStringLiteral("units"), m_units.simplified());
  o.insert(QStringLiteral("widget"), m_widget.simplified());
  o.insert(QStringLiteral("fftSamplingRate"), m_fftSamplingRate);
  o.insert(QStringLiteral("overviewDisplay"), m_displayInOverview);
  return o;
}

/**
 * Reads dataset information from the given @a object.
 *
 * @return @c true on read success, @c false on failure
 */
bool JSON::Dataset::read(const QJsonObject &object)
{
  if (!object.isEmpty())
  {
    m_min = SAFE_READ(object, "min", 0).toDouble();
    m_max = SAFE_READ(object, "max", 0).toDouble();
    m_index = SAFE_READ(object, "index", 0).toInt();
    m_fft = SAFE_READ(object, "fft", false).toBool();
    m_led = SAFE_READ(object, "led", false).toBool();
    m_log = SAFE_READ(object, "log", false).toBool();
    m_xAxisId = SAFE_READ(object, "xAxis", 0).toInt();
    m_alarm = SAFE_READ(object, "alarm", 0).toDouble();
    m_graph = SAFE_READ(object, "graph", false).toBool();
    m_ledHigh = SAFE_READ(object, "ledHigh", 0).toDouble();
    m_fftSamples = SAFE_READ(object, "fftSamples", 256).toInt();
    m_title = SAFE_READ(object, "title", "").toString().simplified();
    m_value = SAFE_READ(object, "value", "").toString().simplified();
    m_units = SAFE_READ(object, "units", "").toString().simplified();
    m_widget = SAFE_READ(object, "widget", "").toString().simplified();
    m_fftSamplingRate = SAFE_READ(object, "fftSamplingRate", 100).toInt();
    m_fftWindowFn = SAFE_READ(object, "fftWindow", "").toString().simplified();
    m_displayInOverview = SAFE_READ(object, "overviewDisplay", false).toBool();
    if (m_value.isEmpty())
      m_value = QStringLiteral("--.--");

    m_min = qMin(m_min, m_max);
    m_max = qMax(m_min, m_max);

    return true;
  }

  return false;
}
